const express = require('express');
const bcrypt = require('bcryptjs');
const jwt = require('jsonwebtoken');
const passport = require('passport');
const GoogleStrategy = require('passport-google-oauth20').Strategy;
const AppleStrategy = require('passport-apple');
const { pool } = require('./database');
const fs = require('fs');
const path = require('path');

const router = express.Router();
const JWT_SECRET = process.env.JWT_SECRET || 'oneai-secret-key-2024';

// Apple 로그인 키 설정
const APPLE_KEY_PATH = process.env.APPLE_KEY_PATH || path.join(__dirname, '../config/apple-auth-key.p8');
const APPLE_KEY_ID = process.env.APPLE_KEY_ID;
const APPLE_TEAM_ID = process.env.APPLE_TEAM_ID;
const APPLE_CLIENT_ID = process.env.APPLE_CLIENT_ID;

// 토큰 검증 미들웨어
const authenticateToken = (req, res, next) => {
  const authHeader = req.headers['authorization'];
  const token = authHeader && authHeader.split(' ')[1];

  if (!token) {
    return res.status(401).json({ error: '인증이 필요합니다.' });
  }

  jwt.verify(token, JWT_SECRET, (err, user) => {
    if (err) {
      return res.status(403).json({ error: '유효하지 않은 토큰입니다.' });
    }
    req.user = user;
    next();
  });
};

// Passport Google OAuth 설정
passport.use(new GoogleStrategy({
  clientID: process.env.GOOGLE_CLIENT_ID,
  clientSecret: process.env.GOOGLE_CLIENT_SECRET,
  callbackURL: "/api/auth/oauth/google/callback",
  scope: ['profile', 'email']
},
async function(accessToken, refreshToken, profile, done) {
  try {
    // 기존 사용자 확인
    const result = await pool.query('SELECT * FROM users WHERE google_id = $1', [profile.id]);
    
    if (result.rows.length > 0) {
      return done(null, result.rows[0]);
    }
    
    // 새 사용자 생성
    const newUser = await pool.query(
      'INSERT INTO users (email, username, google_id, profile_image) VALUES ($1, $2, $3, $4) RETURNING *',
      [profile.emails[0].value, profile.displayName, profile.id, profile.photos[0]?.value]
    );
    
    return done(null, newUser.rows[0]);
  } catch (error) {
    return done(error, null);
  }
}));

// Apple OAuth 설정
passport.use(new AppleStrategy({
  clientID: APPLE_CLIENT_ID,
  teamID: APPLE_TEAM_ID,
  keyID: APPLE_KEY_ID,
  keyFilePath: APPLE_KEY_PATH,
  callbackURL: "/api/auth/oauth/apple/callback",
  passReqToCallback: true
},
async function(req, accessToken, refreshToken, idToken, profile, done) {
  try {
    const appleId = profile.id;
    const email = profile.email;
    const name = req.body.user ? JSON.parse(req.body.user).name : null;
    
    // 기존 사용자 확인
    const result = await pool.query('SELECT * FROM users WHERE apple_id = $1', [appleId]);
    
    if (result.rows.length > 0) {
      return done(null, result.rows[0]);
    }
    
    // 새 사용자 생성
    const newUser = await pool.query(
      'INSERT INTO users (email, username, apple_id) VALUES ($1, $2, $3) RETURNING *',
      [email, name?.firstName + ' ' + name?.lastName || email.split('@')[0], appleId]
    );
    
    return done(null, newUser.rows[0]);
  } catch (error) {
    return done(error, null);
  }
}));

// 회원가입
router.post('/register', async (req, res) => {
  try {
    const { email, password, username } = req.body;
    
    // 이메일 중복 확인
    const userExists = await pool.query('SELECT id FROM users WHERE email = $1', [email]);
    if (userExists.rows.length > 0) {
      return res.status(400).json({ error: '이미 등록된 이메일입니다.' });
    }
    
    // 비밀번호 해시화
    const salt = await bcrypt.genSalt(10);
    const passwordHash = await bcrypt.hash(password, salt);
    
    // 사용자 생성
    const result = await pool.query(
      'INSERT INTO users (email, password_hash, username) VALUES ($1, $2, $3) RETURNING id, email, username',
      [email, passwordHash, username]
    );
    
    const user = result.rows[0];
    const token = jwt.sign({ userId: user.id, email: user.email }, JWT_SECRET, { expiresIn: '7d' });
    
    res.status(201).json({
      success: true,
      data: { user, token },
      message: '회원가입이 완료되었습니다.'
    });
  } catch (error) {
    console.error('Registration error:', error);
    res.status(500).json({ error: '회원가입 처리 중 오류가 발생했습니다.' });
  }
});

// 로그인
router.post('/login', async (req, res) => {
  try {
    const { email, password } = req.body;
    
    // 사용자 조회
    const result = await pool.query('SELECT * FROM users WHERE email = $1', [email]);
    if (result.rows.length === 0) {
      return res.status(401).json({ error: '이메일 또는 비밀번호가 올바르지 않습니다.' });
    }
    
    const user = result.rows[0];
    
    // 비밀번호 확인
    const isValidPassword = await bcrypt.compare(password, user.password_hash);
    if (!isValidPassword) {
      return res.status(401).json({ error: '이메일 또는 비밀번호가 올바르지 않습니다.' });
    }
    
    // JWT 토큰 생성
    const token = jwt.sign({ userId: user.id, email: user.email }, JWT_SECRET, { expiresIn: '7d' });
    
    // 비밀번호 제거
    delete user.password_hash;
    
    res.json({
      success: true,
      data: { user, token },
      message: '로그인 성공'
    });
  } catch (error) {
    console.error('Login error:', error);
    res.status(500).json({ error: '로그인 처리 중 오류가 발생했습니다.' });
  }
});

// Google OAuth 로그인 시작
router.get('/oauth/google', passport.authenticate('google', {
  scope: ['profile', 'email'],
  prompt: 'select_account'
}));

// Google OAuth 콜백
router.get('/oauth/google/callback',
  passport.authenticate('google', {
    session: false,
    failureRedirect: '/login?error=google_oauth_failed'
  }),
  async (req, res) => {
    try {
      const token = jwt.sign(
        { userId: req.user.id, email: req.user.email },
        JWT_SECRET,
        { expiresIn: '7d' }
      );
      
      res.redirect(`/login-callback.html?token=${token}`);
    } catch (error) {
      console.error('Google OAuth callback error:', error);
      res.redirect('/login.html?error=oauth_failed');
    }
  }
);

// Apple 로그인 시작
router.get('/oauth/apple', passport.authenticate('apple', {
  scope: ['email', 'name'],
  session: false
}));

// Apple OAuth 콜백
router.post('/oauth/apple/callback',
  passport.authenticate('apple', {
    session: false,
    failureRedirect: '/login?error=apple_oauth_failed'
  }),
  async (req, res) => {
    try {
      const token = jwt.sign(
        { userId: req.user.id, email: req.user.email },
        JWT_SECRET,
        { expiresIn: '7d' }
      );
      
      res.redirect(`/login-callback.html?token=${token}&provider=apple`);
    } catch (error) {
      console.error('Apple OAuth callback error:', error);
      res.redirect('/login.html?error=oauth_failed');
    }
  }
);

module.exports = {
  router,
  authenticateToken,
  JWT_SECRET
};
